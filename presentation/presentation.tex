
\documentclass{beamer}
\title{Understanding The Haskell FFI}
\author{Tim Skinner}
\date{\today}
\mode<presentation> {\usetheme{Montpellier}}

\usepackage[english]{babel}
\usepackage[latin1]{inputenc}
\usepackage{times}
\usepackage[T1]{fontenc}
\usepackage{hyperref}
\usepackage{listings}
\usepackage{color}

\definecolor{comment}{rgb}{0,0.6,0}
\definecolor{keyword}{rgb}{0,0,0.6}
\definecolor{string}{rgb}{0.58,0,0.82}

\lstset {
    backgroundcolor=\color{white},
    basicstyle=\tiny,
    keywordstyle=\color{keyword},
    commentstyle=\color{comment},
    showspaces=false,
    showstringspaces=false,
    showtabs=false,
    stringstyle=\color{string},
    tabsize=4,
    frame=shadowbox
}

\newcommand{\chref}[3] {
    {\color{#1} \href{#2}{\underline{#3}}}
}

\newcommand{\cmd}[1]{
    \vspace{2mm}
    \fcolorbox{gray}{black}{\tt {\color{white} user@host\$ #1}}
    \vspace{2mm}\\
}

\begin{document}

\begin{frame}
    \titlepage
\end{frame}

\section{Introduction}
\begin{frame}
    \frametitle{What is the FFI?}

    The FFI allows Haskell code to interoperate with native code by allowing
    haskell applications to call or be called by native functions through
    static and shared libraries and object files.

\end{frame}

\begin{frame}
    \frametitle{What is Native code?}

    The \chref{darkgray}
    {http://www.cse.unsw.edu.au/~chak/haskell/ffi/ffi/ffi.html} {Haskell 98
    Addendum on FFI} defines a mechanism for interoperating with code that uses
    the platforms C calling convention.

    The standard leaves room for implementations to support other conventions,
    such as C++ or Java, but these are not supported by GHC.
\end{frame}

\begin{frame}
    \frametitle{A Brief Aside on Platform Dependence}

    Since the FFI deals with implementation defined and platform specific code,
    we will pick a reference platform for the examples.  In this case:

    \begin{itemize}
        \item {GNU + Linux}
        \item {\chref{darkgray}{http://www.uclibc.org/docs/psABI-x86_64.pdf}{AMD64 System V ABI}}
        \item {\chref{darkgray}{http://www.skyfree.org/linux/references/ELF_Format.pdf}{ELF File Format}}
        \item {GHC 7.4}
        \item {GCC 4.7}
        \item {libc 4.6}
    \end{itemize}
\end{frame}

\section{Symbols, Linking, and ABIs}
\begin{frame}
    \frametitle{Background}

    To understand how the FFI on works on our target platform we need to
    understand how C applications work.  Let's look at how we go from source
    code to a running application on our target platform.
\end{frame}

\begin{frame}
    \frametitle{Definition: Symbol}

    Symbols represent things such as data, functions, ELF sections, or
    debugging resources.  The way that symbol names are created is language and
    compiler specific, and is part of the compiler ABI.
\end{frame}

\begin{frame}
    \frametitle{Getting Into Specifics}

    Let's take a look at example.  We'll create a program in C that calls a
    function, {\tt generate\_message}, and see what happens.

\end{frame}

\begin{frame}
    \frametitle {Our first example - {\tt hello.c}}
    \lstinputlisting[language=C]{"../samples/hello_c/hello.c"}
\end{frame}

\begin{frame}
    \frametitle{Compiling Files}

    Although we can generate an executable directly from our source code, it's
    illustrative to first generate an object file:

    \cmd{gcc -std=gnu99 -c hello.c -o hello.o}

    Next we can link our object file with the system libraries to generate our
    final executable. gcc is helping us out here by defining some default
    parameters, but we could also do this manually by running {\tt ld}
    directly.

    \cmd{gcc hello.o -o hello}
\end{frame}

\begin{frame}
    \frametitle{The ELF Object File Format}

    The ELF file format consists of an ELF header containing metadata
    information and offets to a number of sections.  The specific sections that
    are included in a file vary depending on the type of file.  Of specific
    interest to us are the \emph{Symbol Table} and the \emph{Relocations}

    We can use the {\tt readelf} command to look at the contents of an ELF
    file.
\end{frame}

\begin{frame}[fragile]
    \frametitle{ELF Object File Symbol Table}
    \begin{tiny}
     \begin{verbatim}
Symbol table '.symtab' contains 14 entries:
   Num:    Value          Size Type    Bind   Vis      Ndx Name
     0: 0000000000000000     0 NOTYPE  LOCAL  DEFAULT  UND
     1: 0000000000000000     0 FILE    LOCAL  DEFAULT  ABS hello.c
     2: 0000000000000000     0 SECTION LOCAL  DEFAULT    1
     3: 0000000000000000     0 SECTION LOCAL  DEFAULT    3
     4: 0000000000000000     0 SECTION LOCAL  DEFAULT    4
     5: 0000000000000000     0 SECTION LOCAL  DEFAULT    5
     6: 0000000000000000     0 SECTION LOCAL  DEFAULT    7
     7: 0000000000000000     0 SECTION LOCAL  DEFAULT    8
     8: 0000000000000000     0 SECTION LOCAL  DEFAULT    6
     9: 0000000000000000    52 FUNC    GLOBAL DEFAULT    1 generate_message
    10: 0000000000000000     0 NOTYPE  GLOBAL DEFAULT  UND asprintf
    11: 0000000000000034    60 FUNC    GLOBAL DEFAULT    1 main
    12: 0000000000000000     0 NOTYPE  GLOBAL DEFAULT  UND puts
    13: 0000000000000000     0 NOTYPE  GLOBAL DEFAULT  UND free
    \end{verbatim}
    \end{tiny}
\end{frame}

\begin{frame}[fragile]
    \frametitle{A Side Note on C++}
    If we'd used a C++ compiler to compile our code, the entry with our
    {\tt generate\_message} symbol would have looked more like this:
    \fbox{\parbox{\linewidth}{\begin{tiny}
        {\tt 52: 00000000004005ac    52 FUNC    GLOBAL DEFAULT   13 \_Z16generate\_messagePKc}
    \end{tiny}}}
    C++ uses name mangling to manage polymorphism.  You can get around this by
    using {\tt extern "C"}, but we are just going to avoid it for this talk.
\end{frame}

\begin{frame}[fragile]
    \frametitle{ELF Object File .text Relocations}
    \begin{tiny}
        \begin{verbatim}
Relocation section '.rela.text' at offset 0x678 contains 6 entries:
  Offset          Info           Type           Sym. Value    Sym. Name + Addend
00000000001d  00050000000a R_X86_64_32       0000000000000000 .rodata + 0
00000000002a  000a00000002 R_X86_64_PC32     0000000000000000 asprintf - 4
000000000044  00050000000a R_X86_64_32       0000000000000000 .rodata + a
000000000049  000900000002 R_X86_64_PC32     0000000000000000 generate_message - 4
000000000059  000c00000002 R_X86_64_PC32     0000000000000000 puts - 4
000000000065  000d00000002 R_X86_64_PC32     0000000000000000 free - 4
        \end{verbatim}
    \end{tiny}
\end{frame}

\begin{frame}
    \frametitle{Meaning of the ELF sections}
    The symbol table is a persistant hash table that is used for looking up
    symbols \footnote{The {\tt .dynsym} section in executables servers a
    similar purpose}.  A Relocation section \footnote{There are relocation
    sections for several different sections in an ELF file} contains offsets
    used at load time by the linker.
\end{frame}

\begin{frame}
    \frametitle{Moving On}
    So we have symbols and relocations for our function.  What now?
\end{frame}

\begin{frame}
    \frametitle{Generating an Assembly Language File}
     We can look at the assembly being generated by gcc by running:
     \cmd{gcc -S hello.c -o hello.s}
\end{frame}

\begin{frame}[fragile]
    \frametitle{An Excerpt from {\tt hello.s}}

    \begin{tiny}
        \begin{verbatim}
# The start of our function
generate_message:
.LFB0:
        # .LC1, which contains "World", was pushed to %edi,
        # which our ABI uses as the first function parameter register
        .cfi_startproc
        pushq   %rbp
        .cfi_def_cfa_offset 16
        .cfi_offset 6, -16
        movq    %rsp, %rbp
        .cfi_def_cfa_register 6
        subq    $32, %rsp
        movq    %rdi, -24(%rbp)
        movq    $0, -8(%rbp)
        movq    -24(%rbp), %rdx
        leaq    -8(%rbp), %rax

        # Push .LC0, which contains "Hello, %s", into %esi, which is the
        # second parameter register
        movl    $.LC0, %esi
        movq    %rax, %rdi
        movl    $0, %eax
        call    asprintf
        movq    -8(%rbp), %rax
        leave
        \end{verbatim}
    \end{tiny}
\end{frame}

\begin{frame}
    \frametitle{The End Result}

    We don't need to care much about the details of that code.  Here are our
    takeaway points:

    \begin{itemize}
        \item{The compiler ABI defines how we generate symbol names}
        \item{Symbol names are the keys for entries in symbol tables}
        \item{The linker relocates code, we can find it thanks to relocations}
        \item{The calling convention defines how we call functions}
        \item{The FFI ensures that our haskell code interoperates with native
              code by ensuring that the ABI and calling conventions are met}
    \end{itemize}
\end{frame}

\section{Native and Haskell Types}
\begin{frame}
    \frametitle{FFI Supplied Types}

    The FFI provides for Haskell analogues to many basic C datatypes in {\tt
    Foreign.C.Types}, and a set of utility functions for dealing with C Strings
    in {\tt Foreign.C.String}
\end{frame}
\begin{frame}
    \frametitle{Common Types in {\tt Foreign.C.Types}}
    \begin{tiny}
        \begin{table}
            \begin{tabular}{| l | r |}
                \hline
                {\bf C Type} & {\bf Haskell Type} \\ \hline
                {\tt int8\_t}, {\tt char} & {\tt CChar} \\ \hline
                {\tt int}, {\tt int32\_t}, {\tt long}& {\tt CInt} \\ \hline
                {\tt unsigned}, {\tt unsigned int}, {\tt unsigned long},
                {\tt uint32\_t} & {\tt CUInt} \\ \hline
                {\tt long long}, {\tt int64\_t} & {\tt CLong} \\ \hline
                {\tt time\_t} & {\tt CTime} \\ \hline
                {\tt size\_t} & {\tt CSize} \\ \hline
                {\tt ptrdiff\_t} & {\tt CPtrdiff} \\ \hline
            \end{tabular}
            \caption{\tiny A Mapping Between C and Haskell Types}
        \end{table}
    \end{tiny}
\end{frame}
\begin{frame}[fragile]
    \frametitle{C Strings}
    The FFI provides a number of utility functions for working with C Strings.
    {\tt Data.ByteString} also provides functions for marshalling between
    ByteString and CString types.
    \begin{lstlisting}{language=Haskell}
    type CString = Ptr CChar
    type CStringLen = (Ptr CChar, Int)
    \end{lstlisting}
\end{frame}
\begin{frame}
    \frametitle{Useful C String Functions}
    \begin{itemize}
        \item{newCString :: String -> IO CString}
        \item{peekCString :: CString -> IO String}
        \item{withCString :: String -> (CString -> IO a) -> IO a}
        \item{packCString :: CString -> IO ByteString}
        \item{useAsCString :: ByteString -> (CString -> IO a) -> IO a}
    \end{itemize}
\end{frame}
\begin{frame}
    \frametitle{Marshalling}
    Marshalling is how we make data shared between C and Haskell mutually
    intelligable.  Native C types are mapped to Haskell types through
    {\tt Foreign.C.Types}.  Additional support functions for C strings are
    available in {\tt Foreign.C.String}
\end{frame}
\begin{frame}
    \frametitle{Marshalling Gotchas}
    There are a few specific things that we need to be aware of before we get
    started:
    \begin{itemize}
        \item{You may need to account for Endianness of data}
        \item{Fundamental types may have different bit widths between Haskell
            and C, e.g. Ints}
        \item{The width of some types may be architecture dependant}
        \item{Pointer operations are impure}
    \end{itemize}
\end{frame}
\begin{frame}
    \frametitle{Pointers}
    A pointer represents a raw machine address.  The FFI defines
    three\footnote{There are additional pointer types defined by
        the FFI that are analogous to C's {\tt intptr\_t} and {\tt uintptr\_t
    } types} types of
    pointers that we are interested in:
    \begin{itemize}
        \item{{\tt Ptr a} A raw machine address.  In many cases, {\tt a} is a
            storable.}
        \item{{\tt FunPtr a} A pointer to a foreign function.  On some
                architectures it is possible to cast between a {\tt Ptr a} and
            a {\tt FunPtr a}}
        \item{{\tt StablePtr a} A pointer to a Haskell expression that will not
                be touched by the garbage collector.  This may be necessary if
            you exposing a native API implemented in Haskell}
    \end{itemize}
\end{frame}
\begin{frame}
    \frametitle{Definition: Opaque Pointer}
    An opaque pointer does not need to be marshalled and can in most cases be
    treated as a pointer to an existential type.  Using mutators instead of
    direct structure access in native APIs can simplify their use in the FFI
    because of this.
\end{frame}
\begin{frame}[fragile]
    \frametitle{Creating Opaque Types}

    \begin{lstlisting}{language=haskell,frame=double}
data MyType = MyType
type MyTypeHandle = Ptr MyType
newtype MyOneshotHandle = Ptr MyOneshotHandle
    \end{lstlisting}
\end{frame}
\begin{frame}[fragile]
    \frametitle{Storable Typeclass}
    \begin{lstlisting}{language=haskell}
    class Storable a where
        -- Minimal Complete Definition:
        -- sizeOf,alignment
        -- one of: peek, peekElemOff, peekByteOff
        -- one of: poke, pokeElemOff, pokeByteOff

        sizeOf      :: Storable a => a -> Int
        alignment   :: Storable a => a -> int

        peek        :: Storable a => Ptr a -> IO a
        peekElemOff :: Storable a => Ptr a -> Int -> IO a
        peekByteOff :: Storable a => Ptr b -> Int -> IO a

        poke        :: Storable a => Ptr a -> a -> IO ()
        pokeElemOff :: Storable a => Ptr a -> Int -> a -> IO ()
        pokeByteOff :: Storable a => Ptr b -> Int -> a -> IO ()
    \end{lstlisting}
\end{frame}
\begin{frame}
    \frametitle{Implementing Storable}
    \begin{itemize}
        \item {{\tt sizeOf} \\
                {\it Return the size in bytes of the data structure}
            }
        \item {{\tt alignment} \\
                {\it Return the byte alignment of the data structure}
            }
        \item {One of: {\tt peek}, {\tt peekElemOff}, or {\tt peekByteOff} \\
                {\it Read data from the provided memory address}
            }
        \item {One of: {\tt poke}, {\tt pokeElemOff}, or {\tt pokeByteOff} \\
                {\it Write data to the provided memory address}
            }
    \end{itemize}
\end{frame}
\begin{frame}[fragile]
    \frametitle{Storable Example: NetfilterQueue.hs}
    \begin{lstlisting}{language=Haskell}
data NfGenMsg = NfGenMsg {packet_id :: CUInt, hw_protocol :: CUShort, hook :: CUChar}
instance Storable NfGenMsg where
    sizeOf _    = sizeOf (0 :: CUInt)   +
                  sizeOf (0 :: CUShort) +
                  sizeOf (0 :: CUChar)
    alignment _ = 16 -- > 8 bytes so we should be 16-byte aligned on x86_64
    peek p      = let ptr1 = castPtr p
                      ptr2 = castPtr $ ptr1 `plusPtr` sizeOf (0 :: CUInt)
                      ptr3 = castPtr $ ptr2 `plusPtr` sizeOf (0 :: CUShort)
                  in do
                      v1 <- peek ptr1
                      v2 <- peek ptr2
                      v3 <- peek ptr3
                      return $ NfGenMsg (fromBigEndian v1) (fromBigEndian v2) v3
    poke ptr (NfGenMsg pkt_id hw_proto hk) =
                let ptr1 = castPtr ptr
                    ptr2 = castPtr $ ptr1 `plusPtr` sizeOf (0 :: CUInt)
                    ptr3 = castPtr $ ptr2 `plusPtr` sizeOf (0 :: CUShort)
                in do
                    poke ptr1 $ toBigEndian pkt_id
                    poke ptr2 $ toBigEndian hw_proto
                    poke ptr3 hk
                    return ()
    \end{lstlisting}
\end{frame}

\section{Functions}
% \subsection{Calling Native Functions}
% \subsection{Exposing Haskell Functions}
% \subsection{Purity}

\section{Tools}
% \subsection{Compilation and Linking}
% \subsection{Automated Wrappers}

\section{Idioms}

\begin{frame}
\end{frame}

\end{document}
