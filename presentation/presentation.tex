
\documentclass{beamer}
\title{Understanding The Haskell FFI}
\author{Tim Skinner}
\date{\today}
\mode<presentation> { \usetheme{Berlin} }

\usepackage[english]{babel}
\usepackage[latin1]{inputenc}
\usepackage{times}
\usepackage[T1]{fontenc}
\usepackage{hyperref}
\usepackage{listings}
\usepackage{color}

\definecolor{comment}{rgb}{0,0.6,0}
\definecolor{keyword}{rgb}{0,0,0.6}
\definecolor{string}{rgb}{0.58,0,0.82}

\lstset {
    backgroundcolor=\color{white},
    basicstyle=\tiny,
    keywordstyle=\color{keyword},
    commentstyle=\color{comment},
    showspaces=false,
    showstringspaces=false,
    showtabs=false,
    stringstyle=\color{string},
    tabsize=4
}

\newcommand{\chref}[3] {
    {\color{#1} \href{#2}{\underline{#3}}}
}

\newcommand{\cmd}[1]{
    \fcolorbox{gray}{black}{\tt {\color{white} user@host\$ #1}}
}

\begin{document}

\begin{frame}
    \titlepage
\end{frame}

\section*{Outline}
\begin{frame}
    \begin{tiny}
        \tableofcontents
    \end{tiny}
\end{frame}

\section{Introduction}
\begin{frame}
    \frametitle{What is the FFI?}
    The FFI allows Haskell code to interoperate with Native code.
    \begin{enumerate}
        \item{Allow Haskell applications to call native functions}
        \item{Make functions in a Haskell application available to native
            applications}
    \end{enumerate}
\end{frame}

\begin{frame}
    \frametitle{What is Native code?}

    The \chref{darkgray}
    {http://www.cse.unsw.edu.au/~chak/haskell/ffi/ffi/ffi.html} {Haskell 98
    Addendum on FFI} defines a mechanism for interoperating with code that uses
    the platforms C calling convention.

    The standard leaves room for implementations to support other conventions,
    such as C++ or Java, but these are not supported by GHC.
\end{frame}

\begin{frame}
    \frametitle{A Brief Aside on Platform Dependence}

    Since the FFI deals with implementation defined and platform specific code,
    we will pick a reference platform for the examples.  In this case:

    \begin{itemize}
        \item {GNU + Linux}
        \item {\chref{darkgray}{http://www.uclibc.org/docs/psABI-x86_64.pdf}{AMD64 System V ABI}}
        \item {\chref{darkgray}{http://downloads.openwatcom.org/ftp/devel/docs/elf-64-gen.pdf}{ELF64 File Format}}
        \item {GHC 7.4}
        \item {GCC 4.7}
        \item {libc 4.6}
    \end{itemize}
\end{frame}

\section{Symbols, Linking, and ABIs}
\begin{frame}
    \frametitle{Background}

    To understand how the FFI on works on our target platform we need to
    understand how C applications work.  Let's look at how we go from source
    code to a running application on our target platform.
\end{frame}

\begin{frame}
    \frametitle {Our first example - {\tt hello.c}}
    \lstinputlisting[language=C]{"../samples/hello.c"}
\end{frame}

\begin{frame}
    \frametitle{Compiling Files}

    Although we can generate an executable directly from our source code, it's
    illustrative to first generate an object file:

    \cmd{gcc -std=gnu99 -c hello.c -o hello.o}

    Next we can link our object file with the system libraries to generate our
    final executable. gcc is helping us out here by defining some default
    parameters, but we could also do this manually by running {\tt ld}
    directly.

    \cmd{gcc hello.o -o hello}
\end{frame}

\begin{frame}
    \frametitle{Our Application's ELF Objects}

    Now that we have generated an object file and our final ELF executable, we
    can look at the ELF files to see what is being generated by the compiler
    and linker.

    \cmd{readelf -a hello.o hello}
\end{frame}

\begin{frame}
    \frametitle{The ELF File Format}

\end{frame}

\section{Marshalling}
% \subsection{Foreign Types}
% \subsection{Haskell Types}
% \subsection{The Storable Typeclass}

\section{Functions}
% \subsection{Calling Native Functions}
% \subsection{Exposing Haskell Functions}
% \subsection{Purity}

\section{Tools}
% \subsection{Compilation and Linking}
% \subsection{Automated Wrappers}

\section{Idioms}

\begin{frame}
\end{frame}

\end{document}
